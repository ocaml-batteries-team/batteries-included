<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="BatOption.html">
<link rel="next" href="BatParserCo.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="BatArray" rel="Chapter" href="BatArray.html">
<link title="BatAvlTree" rel="Chapter" href="BatAvlTree.html">
<link title="BatBase64" rel="Chapter" href="BatBase64.html">
<link title="BatBig_int" rel="Chapter" href="BatBig_int.html">
<link title="BatBigarray" rel="Chapter" href="BatBigarray.html">
<link title="BatBitSet" rel="Chapter" href="BatBitSet.html">
<link title="BatBool" rel="Chapter" href="BatBool.html">
<link title="BatBounded" rel="Chapter" href="BatBounded.html">
<link title="BatBuffer" rel="Chapter" href="BatBuffer.html">
<link title="BatCache" rel="Chapter" href="BatCache.html">
<link title="BatChar" rel="Chapter" href="BatChar.html">
<link title="BatCharParser" rel="Chapter" href="BatCharParser.html">
<link title="BatComplex" rel="Chapter" href="BatComplex.html">
<link title="BatConcurrent" rel="Chapter" href="BatConcurrent.html">
<link title="BatDeque" rel="Chapter" href="BatDeque.html">
<link title="BatDigest" rel="Chapter" href="BatDigest.html">
<link title="BatDllist" rel="Chapter" href="BatDllist.html">
<link title="BatDynArray" rel="Chapter" href="BatDynArray.html">
<link title="BatEnum" rel="Chapter" href="BatEnum.html">
<link title="BatFile" rel="Chapter" href="BatFile.html">
<link title="BatFingerTree" rel="Chapter" href="BatFingerTree.html">
<link title="BatFloat" rel="Chapter" href="BatFloat.html">
<link title="BatFormat" rel="Chapter" href="BatFormat.html">
<link title="BatGc" rel="Chapter" href="BatGc.html">
<link title="BatGenlex" rel="Chapter" href="BatGenlex.html">
<link title="BatGlobal" rel="Chapter" href="BatGlobal.html">
<link title="BatHashcons" rel="Chapter" href="BatHashcons.html">
<link title="BatHashtbl" rel="Chapter" href="BatHashtbl.html">
<link title="BatHeap" rel="Chapter" href="BatHeap.html">
<link title="BatIMap" rel="Chapter" href="BatIMap.html">
<link title="BatIO" rel="Chapter" href="BatIO.html">
<link title="BatISet" rel="Chapter" href="BatISet.html">
<link title="BatInnerIO" rel="Chapter" href="BatInnerIO.html">
<link title="BatInnerPervasives" rel="Chapter" href="BatInnerPervasives.html">
<link title="BatInnerWeaktbl" rel="Chapter" href="BatInnerWeaktbl.html">
<link title="BatInt" rel="Chapter" href="BatInt.html">
<link title="BatInt32" rel="Chapter" href="BatInt32.html">
<link title="BatInt64" rel="Chapter" href="BatInt64.html">
<link title="BatInterfaces" rel="Chapter" href="BatInterfaces.html">
<link title="BatLazyList" rel="Chapter" href="BatLazyList.html">
<link title="BatLexing" rel="Chapter" href="BatLexing.html">
<link title="BatList" rel="Chapter" href="BatList.html">
<link title="BatLog" rel="Chapter" href="BatLog.html">
<link title="BatLogger" rel="Chapter" href="BatLogger.html">
<link title="BatMap" rel="Chapter" href="BatMap.html">
<link title="BatMarshal" rel="Chapter" href="BatMarshal.html">
<link title="BatMultiMap" rel="Chapter" href="BatMultiMap.html">
<link title="BatMultiPMap" rel="Chapter" href="BatMultiPMap.html">
<link title="BatMutex" rel="Chapter" href="BatMutex.html">
<link title="BatNativeint" rel="Chapter" href="BatNativeint.html">
<link title="BatNum" rel="Chapter" href="BatNum.html">
<link title="BatNumber" rel="Chapter" href="BatNumber.html">
<link title="BatOo" rel="Chapter" href="BatOo.html">
<link title="BatOptParse" rel="Chapter" href="BatOptParse.html">
<link title="BatOption" rel="Chapter" href="BatOption.html">
<link title="BatOrd" rel="Chapter" href="BatOrd.html">
<link title="BatParserCo" rel="Chapter" href="BatParserCo.html">
<link title="BatPathGen" rel="Chapter" href="BatPathGen.html">
<link title="BatPervasives" rel="Chapter" href="BatPervasives.html">
<link title="BatPrintexc" rel="Chapter" href="BatPrintexc.html">
<link title="BatPrintf" rel="Chapter" href="BatPrintf.html">
<link title="BatQueue" rel="Chapter" href="BatQueue.html">
<link title="BatRMutex" rel="Chapter" href="BatRMutex.html">
<link title="BatRandom" rel="Chapter" href="BatRandom.html">
<link title="BatRef" rel="Chapter" href="BatRef.html">
<link title="BatRefList" rel="Chapter" href="BatRefList.html">
<link title="BatResult" rel="Chapter" href="BatResult.html">
<link title="BatReturn" rel="Chapter" href="BatReturn.html">
<link title="BatScanf" rel="Chapter" href="BatScanf.html">
<link title="BatSeq" rel="Chapter" href="BatSeq.html">
<link title="BatSet" rel="Chapter" href="BatSet.html">
<link title="BatSplay" rel="Chapter" href="BatSplay.html">
<link title="BatStack" rel="Chapter" href="BatStack.html">
<link title="BatStream" rel="Chapter" href="BatStream.html">
<link title="BatString" rel="Chapter" href="BatString.html">
<link title="BatSubstring" rel="Chapter" href="BatSubstring.html">
<link title="BatSys" rel="Chapter" href="BatSys.html">
<link title="BatText" rel="Chapter" href="BatText.html">
<link title="BatTuple" rel="Chapter" href="BatTuple.html">
<link title="BatUChar" rel="Chapter" href="BatUChar.html">
<link title="BatUTF8" rel="Chapter" href="BatUTF8.html">
<link title="BatUnit" rel="Chapter" href="BatUnit.html">
<link title="BatUnix" rel="Chapter" href="BatUnix.html">
<link title="BatUref" rel="Chapter" href="BatUref.html">
<link title="BatVect" rel="Chapter" href="BatVect.html">
<link title="Batteries" rel="Chapter" href="Batteries.html">
<link title="BatteriesConfig" rel="Chapter" href="BatteriesConfig.html">
<link title="BatteriesPrint" rel="Chapter" href="BatteriesPrint.html">
<link title="BatteriesThread" rel="Chapter" href="BatteriesThread.html">
<link title="Extlib" rel="Chapter" href="Extlib.html"><title>Batteries user guide : BatOrd</title>
</head>
<body>
<div class="navbar"><a class="pre" href="BatOption.html" title="BatOption">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="BatParserCo.html" title="BatParserCo">Next</a>
</div>
<h1>Module <a href="type_BatOrd.html">BatOrd</a></h1>
<pre><span class="keyword">module</span> BatOrd: <code class="code"><span class="keyword">sig</span></code> <a href="BatOrd.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>An algebraic datatype for ordering.
<p>

    Traditional OCaml code, under the influence of C comparison
    functions, has used int-returning comparisons (&lt; 0, 0 or &gt;
    0). Using an algebraic datatype instead is actually nicer, both
    for comparison producers (no arbitrary choice of a positive and
    negative value) and consumers (nice pattern-matching elimination).<br>
<hr width="100%">
<pre><code><span id="TYPEorder"><span class="keyword">type</span> <code class="type"></code>order</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTorder.Lt"><span class="constructor">Lt</span></span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTorder.Eq"><span class="constructor">Eq</span></span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTorder.Gt"><span class="constructor">Gt</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >An algebraic datatype for ordering.
<p>

    Traditional OCaml code, under the influence of C comparison
    functions, has used int-returning comparisons (&lt; 0, 0 or &gt;
    0). Using an algebraic datatype instead is actually nicer, both
    for comparison producers (no arbitrary choice of a positive and
    negative value) and consumers (nice pattern-matching elimination).</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>


<pre><span id="TYPEord"><span class="keyword">type</span> <code class="type">'a</code> ord</span> = <code class="type">'a -> 'a -> <a href="BatOrd.html#TYPEorder">order</a></code> </pre>
<div class="info">
The type of ordering functions returning an <code class="code">order</code> variant.<br>
</div>

<pre><span id="TYPEcomp"><span class="keyword">type</span> <code class="type">'a</code> comp</span> = <code class="type">'a -> 'a -> int</code> </pre>
<div class="info">
The legacy int-returning comparisons :<ul>
<li>compare a b &lt; 0 means a &lt; b</li>
<li>compare a b = 0 means a = b</li>
<li>compare a b &gt; 0 means a &gt; b</li>
</ul>
<br>
</div>

<pre><span class="keyword">module type</span> <a href="BatOrd.Comp.html">Comp</a> = <code class="code"><span class="keyword">sig</span></code> <a href="BatOrd.Comp.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
We use <code class="code">compare</code> as member name instead of <code class="code">comp</code>, so that the
    Comp modules can be used as the legacy OrderedType interface.
</div>
<pre><span class="keyword">module type</span> <a href="BatOrd.Ord.html">Ord</a> = <code class="code"><span class="keyword">sig</span></code> <a href="BatOrd.Ord.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><pre><span id="VALord0"><span class="keyword">val</span> ord0</span> : <code class="type">int -> <a href="BatOrd.html#TYPEorder">order</a></code></pre><pre><span id="VALord"><span class="keyword">val</span> ord</span> : <code class="type">'a <a href="BatOrd.html#TYPEcomp">comp</a> -> 'a <a href="BatOrd.html#TYPEord">ord</a></code></pre><div class="info">
Returns a variant ordering from a legacy comparison<br>
</div>
<pre><span class="keyword">module</span> <a href="BatOrd.Ord.html">Ord</a>: <div class="sig_block"><code class="code"><span class="keyword">functor</span> (</code><code class="code"><span class="constructor">Comp</span></code><code class="code"> : </code><code class="type"><a href="BatOrd.Comp.html">Comp</a></code><code class="code">) <span class="keywordsign">-&gt;</span> </code><code class="type"><a href="BatOrd.Ord.html">Ord</a></code><code class="type">  with type t = Comp.t</code></div></pre><pre><span id="VALcomp0"><span class="keyword">val</span> comp0</span> : <code class="type"><a href="BatOrd.html#TYPEorder">order</a> -> int</code></pre><pre><span id="VALcomp"><span class="keyword">val</span> comp</span> : <code class="type">'a <a href="BatOrd.html#TYPEord">ord</a> -> 'a <a href="BatOrd.html#TYPEcomp">comp</a></code></pre><div class="info">
Returns an legacy comparison from a variant ordering<br>
</div>
<pre><span class="keyword">module</span> <a href="BatOrd.Comp.html">Comp</a>: <div class="sig_block"><code class="code"><span class="keyword">functor</span> (</code><code class="code"><span class="constructor">Ord</span></code><code class="code"> : </code><code class="type"><a href="BatOrd.Ord.html">Ord</a></code><code class="code">) <span class="keywordsign">-&gt;</span> </code><code class="type"><a href="BatOrd.Comp.html">Comp</a></code><code class="type">  with type t = Ord.t</code></div></pre><pre><span id="VALpoly_comp"><span class="keyword">val</span> poly_comp</span> : <code class="type">'a <a href="BatOrd.html#TYPEcomp">comp</a></code></pre><pre><span id="VALpoly_ord"><span class="keyword">val</span> poly_ord</span> : <code class="type">'a <a href="BatOrd.html#TYPEord">ord</a></code></pre><pre><span id="VALpoly"><span class="keyword">val</span> poly</span> : <code class="type">'a <a href="BatOrd.html#TYPEord">ord</a></code></pre><div class="info">
Polymorphic comparison functions, based on the
    <code class="code"><span class="constructor">Pervasives</span>.compare</code> function from inria's stdlib, have
    polymorphic types: they claim to be able to compare values of any
    type. In practice, they work for only some types, may fail on
    function types and may not terminate on cyclic values.
<p>

    They work by runtime magic, inspecting the values in an untyped
    way. While being an useful hack for base types and simple
    composite types (say <code class="code">(int * float) list</code>, they do not play well
    with functions, type abstractions, and structures that would need
    a finer notion of equality/comparison. For example, if one
    represent sets as balanced binary tree, one may want set with
    equal elements but different balancings to be equal, which would
    not be the case using the polymorphic equality function.
<p>

    When possible, you should therefore avoid relying on these
    polymorphic comparison functions. You should be especially careful
    if your data structure may later evolve to allow cyclic data
    structures or functions.<br>
</div>
<pre><span id="VALrev_ord0"><span class="keyword">val</span> rev_ord0</span> : <code class="type"><a href="BatOrd.html#TYPEorder">order</a> -> <a href="BatOrd.html#TYPEorder">order</a></code></pre><pre><span id="VALrev_comp0"><span class="keyword">val</span> rev_comp0</span> : <code class="type">int -> int</code></pre><pre><span id="VALrev_ord"><span class="keyword">val</span> rev_ord</span> : <code class="type">'a <a href="BatOrd.html#TYPEord">ord</a> -> 'a <a href="BatOrd.html#TYPEord">ord</a></code></pre><pre><span id="VALrev_comp"><span class="keyword">val</span> rev_comp</span> : <code class="type">'a <a href="BatOrd.html#TYPEcomp">comp</a> -> 'a <a href="BatOrd.html#TYPEcomp">comp</a></code></pre><pre><span id="VALrev"><span class="keyword">val</span> rev</span> : <code class="type">'a <a href="BatOrd.html#TYPEord">ord</a> -> 'a <a href="BatOrd.html#TYPEord">ord</a></code></pre><div class="info">
Reverse a given ordering. If <code class="code"><span class="constructor">Int</span>.ord</code> sorts integer by increasing
    order, <code class="code">rev <span class="constructor">Int</span>.ord</code> will sort them by decreasing order.<br>
</div>
<pre><span class="keyword">module</span> <a href="BatOrd.RevOrd.html">RevOrd</a>: <div class="sig_block"><code class="code"><span class="keyword">functor</span> (</code><code class="code"><span class="constructor">Ord</span></code><code class="code"> : </code><code class="type"><a href="BatOrd.Ord.html">Ord</a></code><code class="code">) <span class="keywordsign">-&gt;</span> </code><code class="type"><a href="BatOrd.Ord.html">Ord</a></code><code class="type">  with type t = Ord.t</code></div></pre><pre><span class="keyword">module</span> <a href="BatOrd.RevComp.html">RevComp</a>: <div class="sig_block"><code class="code"><span class="keyword">functor</span> (</code><code class="code"><span class="constructor">Comp</span></code><code class="code"> : </code><code class="type"><a href="BatOrd.Comp.html">Comp</a></code><code class="code">) <span class="keywordsign">-&gt;</span> </code><code class="type"><a href="BatOrd.Comp.html">Comp</a></code><code class="type">  with type t = Comp.t</code></div></pre><pre><span class="keyword">module</span> <a href="BatOrd.Rev.html">Rev</a>: <div class="sig_block"><code class="code"><span class="keyword">functor</span> (</code><code class="code"><span class="constructor">Ord</span></code><code class="code"> : </code><code class="type"><a href="BatOrd.Ord.html">Ord</a></code><code class="code">) <span class="keywordsign">-&gt;</span> </code><code class="type"><a href="BatOrd.Ord.html">Ord</a></code><code class="type">  with type t = Ord.t</code></div></pre><pre><span id="TYPEeq"><span class="keyword">type</span> <code class="type">'a</code> eq</span> = <code class="type">'a -> 'a -> bool</code> </pre>
<div class="info">
The type for equality function.
<p>

    All ordered types also support equality, as equality can be
    derived from ordering. However, there are also cases where
    elements may be compared for equality, but have no natural
    ordering. It is therefore useful to provide equality as an
    independent notion.<br>
</div>

<pre><span id="VALeq_ord0"><span class="keyword">val</span> eq_ord0</span> : <code class="type"><a href="BatOrd.html#TYPEorder">order</a> -> bool</code></pre><pre><span id="VALeq_comp0"><span class="keyword">val</span> eq_comp0</span> : <code class="type">int -> bool</code></pre><pre><span id="VALeq_ord"><span class="keyword">val</span> eq_ord</span> : <code class="type">'a <a href="BatOrd.html#TYPEord">ord</a> -> 'a <a href="BatOrd.html#TYPEeq">eq</a></code></pre><pre><span id="VALeq_comp"><span class="keyword">val</span> eq_comp</span> : <code class="type">'a <a href="BatOrd.html#TYPEcomp">comp</a> -> 'a <a href="BatOrd.html#TYPEeq">eq</a></code></pre><pre><span id="VALeq"><span class="keyword">val</span> eq</span> : <code class="type">'a <a href="BatOrd.html#TYPEord">ord</a> -> 'a <a href="BatOrd.html#TYPEeq">eq</a></code></pre><div class="info">
Derives an equality function from an ordering function.<br>
</div>
<pre><span class="keyword">module type</span> <a href="BatOrd.Eq.html">Eq</a> = <code class="code"><span class="keyword">sig</span></code> <a href="BatOrd.Eq.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><pre><span class="keyword">module</span> <a href="BatOrd.EqOrd.html">EqOrd</a>: <div class="sig_block"><code class="code"><span class="keyword">functor</span> (</code><code class="code"><span class="constructor">Ord</span></code><code class="code"> : </code><code class="type"><a href="BatOrd.Ord.html">Ord</a></code><code class="code">) <span class="keywordsign">-&gt;</span> </code><code class="type"><a href="BatOrd.Eq.html">Eq</a></code><code class="type">  with type t = Ord.t</code></div></pre><pre><span class="keyword">module</span> <a href="BatOrd.EqComp.html">EqComp</a>: <div class="sig_block"><code class="code"><span class="keyword">functor</span> (</code><code class="code"><span class="constructor">Comp</span></code><code class="code"> : </code><code class="type"><a href="BatOrd.Comp.html">Comp</a></code><code class="code">) <span class="keywordsign">-&gt;</span> </code><code class="type"><a href="BatOrd.Eq.html">Eq</a></code><code class="type">  with type t = Comp.t</code></div></pre><pre><span class="keyword">module</span> <a href="BatOrd.Eq.html">Eq</a>: <div class="sig_block"><code class="code"><span class="keyword">functor</span> (</code><code class="code"><span class="constructor">Ord</span></code><code class="code"> : </code><code class="type"><a href="BatOrd.Ord.html">Ord</a></code><code class="code">) <span class="keywordsign">-&gt;</span> </code><code class="type"><a href="BatOrd.Eq.html">Eq</a></code><code class="type">  with type t = Ord.t</code></div></pre><pre><span id="TYPEchoice"><span class="keyword">type</span> <code class="type">'a</code> choice</span> = <code class="type">'a -> 'a -> 'a</code> </pre>
<div class="info">
choice functions, see <code class="code">min</code> and <code class="code">max</code>.<br>
</div>

<pre><span id="VALmin_ord"><span class="keyword">val</span> min_ord</span> : <code class="type">'a <a href="BatOrd.html#TYPEord">ord</a> -> 'a <a href="BatOrd.html#TYPEchoice">choice</a></code></pre><pre><span id="VALmax_ord"><span class="keyword">val</span> max_ord</span> : <code class="type">'a <a href="BatOrd.html#TYPEord">ord</a> -> 'a <a href="BatOrd.html#TYPEchoice">choice</a></code></pre><pre><span id="VALmin_comp"><span class="keyword">val</span> min_comp</span> : <code class="type">'a <a href="BatOrd.html#TYPEcomp">comp</a> -> 'a <a href="BatOrd.html#TYPEchoice">choice</a></code></pre><pre><span id="VALmax_comp"><span class="keyword">val</span> max_comp</span> : <code class="type">'a <a href="BatOrd.html#TYPEcomp">comp</a> -> 'a <a href="BatOrd.html#TYPEchoice">choice</a></code></pre><pre><span id="VALmin"><span class="keyword">val</span> min</span> : <code class="type">'a <a href="BatOrd.html#TYPEord">ord</a> -> 'a <a href="BatOrd.html#TYPEchoice">choice</a></code></pre><div class="info">
<code class="code">min ord</code> will choose the smallest element, according to <code class="code">ord</code>.
    For example, <code class="code">min <span class="constructor">Int</span>.ord 1 2</code> will return <code class="code">1</code>.
<p>

    <code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;the&nbsp;minimum&nbsp;element&nbsp;of&nbsp;a&nbsp;list&nbsp;*)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;list_min&nbsp;ord&nbsp;=&nbsp;<span class="constructor">List</span>.reduce&nbsp;(min&nbsp;ord)<br>
&nbsp;&nbsp;&nbsp;&nbsp;</code><br>
</div>
<pre><span id="VALmax"><span class="keyword">val</span> max</span> : <code class="type">'a <a href="BatOrd.html#TYPEord">ord</a> -> 'a <a href="BatOrd.html#TYPEchoice">choice</a></code></pre><div class="info">
<code class="code">max ord</code> will choose the biggest element according to <code class="code">ord</code>.<br>
</div>
<pre><span id="VALbin_comp"><span class="keyword">val</span> bin_comp</span> : <code class="type">'a <a href="BatOrd.html#TYPEcomp">comp</a> -> 'a -> 'a -> 'b <a href="BatOrd.html#TYPEcomp">comp</a> -> 'b -> 'b -> int</code></pre><pre><span id="VALbin_ord"><span class="keyword">val</span> bin_ord</span> : <code class="type">'a <a href="BatOrd.html#TYPEord">ord</a> -> 'a -> 'a -> 'b <a href="BatOrd.html#TYPEord">ord</a> -> 'b -> 'b -> <a href="BatOrd.html#TYPEorder">order</a></code></pre><div class="info">
binary lifting of the comparison function, using lexicographic order:
    <code class="code">bin_ord ord1 v1 v1' ord2 v2 v2'</code> is <code class="code">ord2 v2 v2'</code> if <code class="code">ord1 v1 v1' = <span class="constructor">Eq</span></code>,
    and <code class="code">ord1 v1 v1'</code> otherwhise.<br>
</div>
<pre><span id="VALbin_eq"><span class="keyword">val</span> bin_eq</span> : <code class="type">'a <a href="BatOrd.html#TYPEeq">eq</a> -> 'a -> 'a -> 'b <a href="BatOrd.html#TYPEeq">eq</a> -> 'b -> 'b -> bool</code></pre><pre><span id="VALmap_eq"><span class="keyword">val</span> map_eq</span> : <code class="type">('a -> 'b) -> 'b <a href="BatOrd.html#TYPEeq">eq</a> -> 'a <a href="BatOrd.html#TYPEeq">eq</a></code></pre><pre><span id="VALmap_comp"><span class="keyword">val</span> map_comp</span> : <code class="type">('a -> 'b) -> 'b <a href="BatOrd.html#TYPEcomp">comp</a> -> 'a <a href="BatOrd.html#TYPEcomp">comp</a></code></pre><pre><span id="VALmap_ord"><span class="keyword">val</span> map_ord</span> : <code class="type">('a -> 'b) -> 'b <a href="BatOrd.html#TYPEord">ord</a> -> 'a <a href="BatOrd.html#TYPEord">ord</a></code></pre><div class="info">
These functions extend an existing equality/comparison/ordering to
    a new domain through a mapping function.  For example, to order
    sets by their cardinality, use <code class="code">map_ord <span class="constructor">Set</span>.cardinal <span class="constructor">Int</span>.ord</code>.
    The input of the mapping function is the type you want to compare,
    so this is the reverse of <code class="code"><span class="constructor">List</span>.map</code>.<br>
</div>
<pre><span class="keyword">module</span> <a href="BatOrd.Incubator.html">Incubator</a>: <code class="code"><span class="keyword">sig</span></code> <a href="BatOrd.Incubator.html">..</a> <code class="code"><span class="keyword">end</span></code></pre></body></html>