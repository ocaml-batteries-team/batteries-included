<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="Up" href="Extlib.ExtHashtbl.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="BatArray" rel="Chapter" href="BatArray.html">
<link title="BatAvlTree" rel="Chapter" href="BatAvlTree.html">
<link title="BatBase64" rel="Chapter" href="BatBase64.html">
<link title="BatBig_int" rel="Chapter" href="BatBig_int.html">
<link title="BatBigarray" rel="Chapter" href="BatBigarray.html">
<link title="BatBitSet" rel="Chapter" href="BatBitSet.html">
<link title="BatBool" rel="Chapter" href="BatBool.html">
<link title="BatBounded" rel="Chapter" href="BatBounded.html">
<link title="BatBuffer" rel="Chapter" href="BatBuffer.html">
<link title="BatCache" rel="Chapter" href="BatCache.html">
<link title="BatChar" rel="Chapter" href="BatChar.html">
<link title="BatCharParser" rel="Chapter" href="BatCharParser.html">
<link title="BatComplex" rel="Chapter" href="BatComplex.html">
<link title="BatConcurrent" rel="Chapter" href="BatConcurrent.html">
<link title="BatDeque" rel="Chapter" href="BatDeque.html">
<link title="BatDigest" rel="Chapter" href="BatDigest.html">
<link title="BatDllist" rel="Chapter" href="BatDllist.html">
<link title="BatDynArray" rel="Chapter" href="BatDynArray.html">
<link title="BatEnum" rel="Chapter" href="BatEnum.html">
<link title="BatFile" rel="Chapter" href="BatFile.html">
<link title="BatFingerTree" rel="Chapter" href="BatFingerTree.html">
<link title="BatFloat" rel="Chapter" href="BatFloat.html">
<link title="BatFormat" rel="Chapter" href="BatFormat.html">
<link title="BatGc" rel="Chapter" href="BatGc.html">
<link title="BatGenlex" rel="Chapter" href="BatGenlex.html">
<link title="BatGlobal" rel="Chapter" href="BatGlobal.html">
<link title="BatHashcons" rel="Chapter" href="BatHashcons.html">
<link title="BatHashtbl" rel="Chapter" href="BatHashtbl.html">
<link title="BatHeap" rel="Chapter" href="BatHeap.html">
<link title="BatIMap" rel="Chapter" href="BatIMap.html">
<link title="BatIO" rel="Chapter" href="BatIO.html">
<link title="BatISet" rel="Chapter" href="BatISet.html">
<link title="BatInnerIO" rel="Chapter" href="BatInnerIO.html">
<link title="BatInnerPervasives" rel="Chapter" href="BatInnerPervasives.html">
<link title="BatInnerWeaktbl" rel="Chapter" href="BatInnerWeaktbl.html">
<link title="BatInt" rel="Chapter" href="BatInt.html">
<link title="BatInt32" rel="Chapter" href="BatInt32.html">
<link title="BatInt64" rel="Chapter" href="BatInt64.html">
<link title="BatInterfaces" rel="Chapter" href="BatInterfaces.html">
<link title="BatLazyList" rel="Chapter" href="BatLazyList.html">
<link title="BatLexing" rel="Chapter" href="BatLexing.html">
<link title="BatList" rel="Chapter" href="BatList.html">
<link title="BatLog" rel="Chapter" href="BatLog.html">
<link title="BatLogger" rel="Chapter" href="BatLogger.html">
<link title="BatMap" rel="Chapter" href="BatMap.html">
<link title="BatMarshal" rel="Chapter" href="BatMarshal.html">
<link title="BatMultiMap" rel="Chapter" href="BatMultiMap.html">
<link title="BatMultiPMap" rel="Chapter" href="BatMultiPMap.html">
<link title="BatMutex" rel="Chapter" href="BatMutex.html">
<link title="BatNativeint" rel="Chapter" href="BatNativeint.html">
<link title="BatNum" rel="Chapter" href="BatNum.html">
<link title="BatNumber" rel="Chapter" href="BatNumber.html">
<link title="BatOo" rel="Chapter" href="BatOo.html">
<link title="BatOptParse" rel="Chapter" href="BatOptParse.html">
<link title="BatOption" rel="Chapter" href="BatOption.html">
<link title="BatOrd" rel="Chapter" href="BatOrd.html">
<link title="BatParserCo" rel="Chapter" href="BatParserCo.html">
<link title="BatPathGen" rel="Chapter" href="BatPathGen.html">
<link title="BatPervasives" rel="Chapter" href="BatPervasives.html">
<link title="BatPrintexc" rel="Chapter" href="BatPrintexc.html">
<link title="BatPrintf" rel="Chapter" href="BatPrintf.html">
<link title="BatQueue" rel="Chapter" href="BatQueue.html">
<link title="BatRMutex" rel="Chapter" href="BatRMutex.html">
<link title="BatRandom" rel="Chapter" href="BatRandom.html">
<link title="BatRef" rel="Chapter" href="BatRef.html">
<link title="BatRefList" rel="Chapter" href="BatRefList.html">
<link title="BatResult" rel="Chapter" href="BatResult.html">
<link title="BatReturn" rel="Chapter" href="BatReturn.html">
<link title="BatScanf" rel="Chapter" href="BatScanf.html">
<link title="BatSeq" rel="Chapter" href="BatSeq.html">
<link title="BatSet" rel="Chapter" href="BatSet.html">
<link title="BatSplay" rel="Chapter" href="BatSplay.html">
<link title="BatStack" rel="Chapter" href="BatStack.html">
<link title="BatStream" rel="Chapter" href="BatStream.html">
<link title="BatString" rel="Chapter" href="BatString.html">
<link title="BatSubstring" rel="Chapter" href="BatSubstring.html">
<link title="BatSys" rel="Chapter" href="BatSys.html">
<link title="BatText" rel="Chapter" href="BatText.html">
<link title="BatTuple" rel="Chapter" href="BatTuple.html">
<link title="BatUChar" rel="Chapter" href="BatUChar.html">
<link title="BatUTF8" rel="Chapter" href="BatUTF8.html">
<link title="BatUnit" rel="Chapter" href="BatUnit.html">
<link title="BatUnix" rel="Chapter" href="BatUnix.html">
<link title="BatUref" rel="Chapter" href="BatUref.html">
<link title="BatVect" rel="Chapter" href="BatVect.html">
<link title="Batteries" rel="Chapter" href="Batteries.html">
<link title="BatteriesConfig" rel="Chapter" href="BatteriesConfig.html">
<link title="BatteriesPrint" rel="Chapter" href="BatteriesPrint.html">
<link title="BatteriesThread" rel="Chapter" href="BatteriesThread.html">
<link title="Extlib" rel="Chapter" href="Extlib.html"><link title="Base operations" rel="Section" href="#6_Baseoperations">
<link title="Enumerations" rel="Section" href="#6_Enumerations">
<link title="Searching" rel="Section" href="#6_Searching">
<link title="Traversing" rel="Section" href="#6_Traversing">
<link title="The polymorphic hash primitive" rel="Section" href="#6_Thepolymorphichashprimitive">
<link title="Boilerplate code" rel="Section" href="#6_Boilerplatecode">
<link title="Override modules" rel="Section" href="#6_Overridemodules">
<link title="Functorial interface" rel="Section" href="#6_Functorialinterface">
<link title="Printing" rel="Subsection" href="#7_Printing">
<title>Batteries user guide : Extlib.ExtHashtbl.Hashtbl</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="Extlib.ExtHashtbl.html" title="Extlib.ExtHashtbl">Up</a>
&nbsp;</div>
<h1>Module <a href="type_Extlib.ExtHashtbl.Hashtbl.html">Extlib.ExtHashtbl.Hashtbl</a></h1>
<pre><span class="keyword">module</span> Hashtbl: <code class="type">BatHashtbl</code></pre><hr width="100%">
<br>
Operations over hashtables.
<p>

    This module replaces Stdlib's
    <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Hashtbl.html">Hashtbl</a>
    module.  All functions and types are provided here.<br>
<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type">('a, 'b)</code> t</span> = <code class="type">('a, 'b) Hashtbl.t</code> </pre>
<div class="info">
A Hashtable wth keys of type 'a and values 'b<br>
</div>

<br>
<span id="6_Baseoperations"><h6>Base operations</h6></span><br>
<pre><span id="VALcreate"><span class="keyword">val</span> create</span> : <code class="type">int -> ('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a></code></pre><div class="info">
<code class="code"><span class="constructor">Hashtbl</span>.create n</code> creates a new, empty hash table, with
   initial size <code class="code">n</code>.  For best results, <code class="code">n</code> should be on the
   order of the expected number of elements that will be in
   the table.  The table grows as needed, so <code class="code">n</code> is just an
   initial guess.<br>
</div>
<pre><span id="VALlength"><span class="keyword">val</span> length</span> : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> int</code></pre><div class="info">
<code class="code"><span class="constructor">Hashtbl</span>.length tbl</code> returns the number of bindings in <code class="code">tbl</code>.
   Multiple bindings are counted multiply, so <code class="code"><span class="constructor">Hashtbl</span>.length</code>
   gives the number of times <code class="code"><span class="constructor">Hashtbl</span>.iter</code> calls its first argument.<br>
</div>
<pre><span id="VALis_empty"><span class="keyword">val</span> is_empty</span> : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> bool</code></pre><div class="info">
<code class="code"><span class="constructor">Hashtbl</span>.is_empty tbl</code> returns <code class="code"><span class="keyword">true</span></code> if there are no bindings
      in <code class="code">tbl</code>, false otherwise.<br>
</div>
<pre><span id="VALadd"><span class="keyword">val</span> add</span> : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> 'a -> 'b -> unit</code></pre><div class="info">
<code class="code"><span class="constructor">Hashtbl</span>.add tbl x y</code> adds a binding of <code class="code">x</code> to <code class="code">y</code> in table <code class="code">tbl</code>.
   Previous bindings for <code class="code">x</code> are not removed, but simply
   hidden. That is, after performing <code class="code"><span class="constructor">Hashtbl</span>.remove</code><code class="code"> tbl x</code>,
   the previous binding for <code class="code">x</code>, if any, is restored.
   (Same behavior as with association lists.)<br>
</div>
<pre><span id="VALremove"><span class="keyword">val</span> remove</span> : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> 'a -> unit</code></pre><div class="info">
<code class="code"><span class="constructor">Hashtbl</span>.remove tbl x</code> removes the current binding of <code class="code">x</code> in <code class="code">tbl</code>,
   restoring the previous binding if it exists.
   It does nothing if <code class="code">x</code> is not bound in <code class="code">tbl</code>.<br>
</div>
<pre><span id="VALremove_all"><span class="keyword">val</span> remove_all</span> : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> 'a -> unit</code></pre><div class="info">
Remove all bindings for the given key<br>
</div>
<pre><span id="VALreplace"><span class="keyword">val</span> replace</span> : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> 'a -> 'b -> unit</code></pre><div class="info">
<code class="code"><span class="constructor">Hashtbl</span>.replace tbl x y</code> replaces the current binding of <code class="code">x</code>
   in <code class="code">tbl</code> by a binding of <code class="code">x</code> to <code class="code">y</code>.  If <code class="code">x</code> is unbound in <code class="code">tbl</code>,
   a binding of <code class="code">x</code> to <code class="code">y</code> is added to <code class="code">tbl</code>.
   This is functionally equivalent to <code class="code"><span class="constructor">Hashtbl</span>.remove</code><code class="code"> tbl x</code>
   followed by <code class="code"><span class="constructor">Hashtbl</span>.add</code><code class="code"> tbl x y</code>.<br>
</div>
<pre><span id="VALcopy"><span class="keyword">val</span> copy</span> : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> ('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a></code></pre><div class="info">
Return a copy of the given hashtable.<br>
</div>
<pre><span id="VALclear"><span class="keyword">val</span> clear</span> : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> unit</code></pre><div class="info">
Empty a hash table.<br>
</div>
<br>
<span id="6_Enumerations"><h6>Enumerations</h6></span><br>
<pre><span id="VALkeys"><span class="keyword">val</span> keys</span> : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> 'a <a href="BatEnum.html#TYPEt">BatEnum.t</a></code></pre><div class="info">
Return an enumeration of all the keys of a hashtable.
      If the key is in the Hashtable multiple times, all occurrences
      will be returned.<br>
</div>
<pre><span id="VALvalues"><span class="keyword">val</span> values</span> : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> 'b <a href="BatEnum.html#TYPEt">BatEnum.t</a></code></pre><div class="info">
Return an enumeration of all the values of a hashtable.<br>
</div>
<pre><span id="VALenum"><span class="keyword">val</span> enum</span> : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> ('a * 'b) <a href="BatEnum.html#TYPEt">BatEnum.t</a></code></pre><div class="info">
Return an enumeration of (key,value) pairs of a hashtable.<br>
</div>
<pre><span id="VALof_enum"><span class="keyword">val</span> of_enum</span> : <code class="type">('a * 'b) <a href="BatEnum.html#TYPEt">BatEnum.t</a> -> ('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a></code></pre><div class="info">
Create a hashtable from a (key,value) enumeration.<br>
</div>
<br>
<span id="6_Searching"><h6>Searching</h6></span><br>
<pre><span id="VALfind"><span class="keyword">val</span> find</span> : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> 'a -> 'b</code></pre><div class="info">
<code class="code"><span class="constructor">Hashtbl</span>.find tbl x</code> returns the current binding of <code class="code">x</code> in <code class="code">tbl</code>,
   or raises <code class="code"><span class="constructor">Not_found</span></code> if no such binding exists.<br>
</div>
<pre><span id="VALfind_all"><span class="keyword">val</span> find_all</span> : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> 'a -> 'b list</code></pre><div class="info">
<code class="code"><span class="constructor">Hashtbl</span>.find_all tbl x</code> returns the list of all data
   associated with <code class="code">x</code> in <code class="code">tbl</code>.
   The current binding is returned first, then the previous
   bindings, in reverse order of introduction in the table.<br>
</div>
<pre><span id="VALfind_default"><span class="keyword">val</span> find_default</span> : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> 'a -> 'b -> 'b</code></pre><div class="info">
Find a binding for the key, and return a default
      value if not found<br>
</div>
<pre><span id="VALfind_option"><span class="keyword">val</span> find_option</span> : <code class="type">('a, 'b) Hashtbl.t -> 'a -> 'b option</code></pre><div class="info">
Find a binding for the key, or return <code class="code"><span class="constructor">None</span></code> if no
      value is found<br>
</div>
<pre><span id="VALmem"><span class="keyword">val</span> mem</span> : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> 'a -> bool</code></pre><div class="info">
<code class="code"><span class="constructor">Hashtbl</span>.mem tbl x</code> checks if <code class="code">x</code> is bound in <code class="code">tbl</code>.<br>
</div>
<br>
<span id="6_Traversing"><h6>Traversing</h6></span>
<p>

   A number of higher-order functions are provided to allow
   purely functional traversal or transformation of hashtables.
   These functions are similar to their counterparts in module
   <a href="BatEnum.html"><code class="code"><span class="constructor">BatEnum</span></code></a>.
<p>

   Whenever you wish to traverse or transfor a hashtable, you have the
   choice between using the more general functions of <a href="BatEnum.html"><code class="code"><span class="constructor">BatEnum</span></code></a>, with
   <a href="BatHashtbl.html#VALkeys"><code class="code"><span class="constructor">BatHashtbl</span>.keys</code></a>, <a href="BatHashtbl.html#VALvalues"><code class="code"><span class="constructor">BatHashtbl</span>.values</code></a>, <a href="BatHashtbl.html#VALenum"><code class="code"><span class="constructor">BatHashtbl</span>.enum</code></a> and <a href="BatHashtbl.html#VALof_enum"><code class="code"><span class="constructor">BatHashtbl</span>.of_enum</code></a>, or the more optimized
   functions of this section.
<p>

   If you are new to OCaml or unsure about data structure, using the
   functions of <a href="BatEnum.html"><code class="code"><span class="constructor">BatEnum</span></code></a> is a safe bet. Should you wish to improve
   performance at the cost of generality, you will always be able to
   rewrite your code to make use of the functions of this section.<br>
<pre><span id="VALiter"><span class="keyword">val</span> iter</span> : <code class="type">('a -> 'b -> unit) -> ('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> unit</code></pre><div class="info">
<code class="code"><span class="constructor">Hashtbl</span>.iter f tbl</code> applies <code class="code">f</code> to all bindings in table <code class="code">tbl</code>.
      <code class="code">f</code> receives the key as first argument, and the associated value
      as second argument. Each binding is presented exactly once to <code class="code">f</code>.
      The order in which the bindings are passed to <code class="code">f</code> is unspecified.
      However, if the table contains several bindings for the same key,
      they are passed to <code class="code">f</code> in reverse order of introduction, that is,
      the most recent binding is passed first.<br>
</div>
<pre><span id="VALfold"><span class="keyword">val</span> fold</span> : <code class="type">('a -> 'b -> 'c -> 'c) -> ('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> 'c -> 'c</code></pre><div class="info">
<code class="code"><span class="constructor">Hashtbl</span>.fold f tbl init</code> computes
   <code class="code">(f kN dN ... (f k1 d1 (f k0 d0 init))...)</code>,
   where <code class="code">k0,k1..kN</code> are the keys of all bindings in <code class="code">tbl</code>,
   and <code class="code">d0,d1..dN</code> are the associated values.
   Each binding is presented exactly once to <code class="code">f</code>.
   The order in which the bindings are passed to <code class="code">f</code> is unspecified.
   However, if the table contains several bindings for the same key,
   they are passed to <code class="code">f</code> in reverse order of introduction, that is,
   the most recent binding is passed first.<br>
</div>
<pre><span id="VALmap"><span class="keyword">val</span> map</span> : <code class="type">('a -> 'b -> 'c) -> ('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> ('a, 'c) <a href="BatHashtbl.html#TYPEt">t</a></code></pre><div class="info">
<code class="code">map f x</code> creates a new hashtable with the same
      keys as <code class="code">x</code>, but with the function <code class="code">f</code> applied to
      all the values<br>
</div>
<pre><span id="VALfilter"><span class="keyword">val</span> filter</span> : <code class="type">('a -> bool) -> ('key, 'a) <a href="BatHashtbl.html#TYPEt">t</a> -> ('key, 'a) <a href="BatHashtbl.html#TYPEt">t</a></code></pre><div class="info">
<code class="code">filter f m</code> returns a new hashtable where only the values <code class="code">a</code> of <code class="code">m</code>
     such that <code class="code">f a = <span class="keyword">true</span></code> remain.<br>
</div>
<pre><span id="VALfilteri"><span class="keyword">val</span> filteri</span> : <code class="type">('key -> 'a -> bool) -> ('key, 'a) <a href="BatHashtbl.html#TYPEt">t</a> -> ('key, 'a) <a href="BatHashtbl.html#TYPEt">t</a></code></pre><div class="info">
<code class="code">filter f m</code> returns a hashtbl where only the key, values pairs
     <code class="code">key</code>, <code class="code">a</code> of <code class="code">m</code> such that <code class="code">f key a = <span class="keyword">true</span></code> remain. The
     bindings are passed to <code class="code">f</code> in increasing order with respect
     to the ordering over the type of the keys.<br>
</div>
<pre><span id="VALfilter_map"><span class="keyword">val</span> filter_map</span> : <code class="type">('key -> 'a -> 'b option) -><br>       ('key, 'a) <a href="BatHashtbl.html#TYPEt">t</a> -> ('key, 'b) <a href="BatHashtbl.html#TYPEt">t</a></code></pre><div class="info">
<code class="code">filter_map f m</code> combines the features of <code class="code">filteri</code> and <code class="code">map</code>.  It
    calls <code class="code">f key0 a0</code>, <code class="code">f key1 a1</code>, <code class="code">f keyn an</code> where <code class="code">a0,a1..an</code> are
    the elements of <code class="code">m</code> and <code class="code">key0..keyn</code> the corresponding keys. It
    returns a hashtbl with associations <code class="code">keyi</code>,<code class="code">bi</code> where <code class="code">f keyi ai =
    <span class="constructor">Some</span> bi</code>.  When <code class="code">f</code> returns <code class="code"><span class="constructor">None</span></code>, the corresponding element of
    <code class="code">m</code> is discarded.<br>
</div>
<br>
<span id="6_Thepolymorphichashprimitive"><h6>The polymorphic hash primitive</h6></span><br>
<pre><span id="VALhash"><span class="keyword">val</span> hash</span> : <code class="type">'a -> int</code></pre><div class="info">
<code class="code"><span class="constructor">Hashtbl</span>.hash x</code> associates a positive integer to any value of
   any type. It is guaranteed that
   if <code class="code">x = y</code> or <code class="code"><span class="constructor">Pervasives</span>.compare x y = 0</code>, then <code class="code">hash x = hash y</code>.
   Moreover, <code class="code">hash</code> always terminates, even on cyclic
   structures.<br>
</div>
<pre><span id="VALhash_param"><span class="keyword">val</span> hash_param</span> : <code class="type">int -> int -> 'a -> int</code></pre><div class="info">
<code class="code"><span class="constructor">Hashtbl</span>.hash_param n m x</code> computes a hash value for <code class="code">x</code>, with the
   same properties as for <code class="code">hash</code>. The two extra parameters <code class="code">n</code> and
   <code class="code">m</code> give more precise control over hashing. Hashing performs a
   depth-first, right-to-left traversal of the structure <code class="code">x</code>, stopping
   after <code class="code">n</code> meaningful nodes were encountered, or <code class="code">m</code> nodes,
   meaningful or not, were encountered. Meaningful nodes are: integers;
   floating-point numbers; strings; characters; booleans; and constant
   constructors. Larger values of <code class="code">m</code> and <code class="code">n</code> means that more
   nodes are taken into account to compute the final hash
   value, and therefore collisions are less likely to happen.
   However, hashing takes longer. The parameters <code class="code">m</code> and <code class="code">n</code>
   govern the tradeoff between accuracy and speed.<br>
</div>
<br>
<span id="6_Boilerplatecode"><h6>Boilerplate code</h6></span><br>
<br>
<span id="7_Printing"><div class="h7">Printing</div></span><br>
<pre><span id="VALprint"><span class="keyword">val</span> print</span> : <code class="type">?first:string -><br>       ?last:string -><br>       ?sep:string -><br>       ?kvsep:string -><br>       ('a <a href="BatInnerIO.html#TYPEoutput">BatInnerIO.output</a> -> 'b -> unit) -><br>       ('a <a href="BatInnerIO.html#TYPEoutput">BatInnerIO.output</a> -> 'c -> unit) -><br>       'a <a href="BatInnerIO.html#TYPEoutput">BatInnerIO.output</a> -> ('b, 'c) <a href="BatHashtbl.html#TYPEt">t</a> -> unit</code></pre><br>
<span id="6_Overridemodules"><h6>Override modules</h6></span><br>
<br>
The following modules replace functions defined in <code class="code"><span class="constructor">Hashtbl</span></code> with functions
       behaving slightly differently but having the same name. This is by design:
       the functions meant to override the corresponding functions of <code class="code"><span class="constructor">Hashtbl</span></code>.<br>
<pre><span class="keyword">module</span> <a href="BatHashtbl.Exceptionless.html">Exceptionless</a>: <code class="code"><span class="keyword">sig</span></code> <a href="BatHashtbl.Exceptionless.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Operations on <code class="code"><span class="constructor">Hashtbl</span></code> without exceptions.
</div>
<pre><span class="keyword">module</span> <a href="BatHashtbl.Infix.html">Infix</a>: <code class="code"><span class="keyword">sig</span></code> <a href="BatHashtbl.Infix.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Infix operators over a <a href="BatHashtbl.html"><code class="code"><span class="constructor">BatHashtbl</span></code></a>
</div>
<pre><span class="keyword">module</span> <a href="BatHashtbl.Labels.html">Labels</a>: <code class="code"><span class="keyword">sig</span></code> <a href="BatHashtbl.Labels.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Operations on <code class="code"><span class="constructor">Hashtbl</span></code> with labels.
</div>
<br>
<span id="6_Functorialinterface"><h6>Functorial interface</h6></span><br>
<pre><span class="keyword">module type</span> <a href="BatHashtbl.HashedType.html">HashedType</a> = <code class="code"><span class="keyword">sig</span></code> <a href="BatHashtbl.HashedType.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><pre><span class="keyword">module type</span> <a href="BatHashtbl.S.html">S</a> = <code class="code"><span class="keyword">sig</span></code> <a href="BatHashtbl.S.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
The output signature of the functor <code class="code"><span class="constructor">Hashtbl</span>.<span class="constructor">Make</span></code>.
</div>
<pre><span class="keyword">module</span> <a href="BatHashtbl.Make.html">Make</a>: <div class="sig_block"><code class="code"><span class="keyword">functor</span> (</code><code class="code"><span class="constructor">H</span></code><code class="code"> : </code><code class="type"><a href="BatHashtbl.HashedType.html">HashedType</a></code><code class="code">) <span class="keywordsign">-&gt;</span> </code><code class="type"><a href="BatHashtbl.S.html">S</a></code><code class="type">  with type key = H.t</code></div></pre><div class="info">
Functor building an implementation of the hashtable structure.
</div>
<pre><span class="keyword">module</span> <a href="BatHashtbl.Cap.html">Cap</a>: <code class="code"><span class="keyword">sig</span></code> <a href="BatHashtbl.Cap.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Capabilities for hashtables.
</div>
</body></html>