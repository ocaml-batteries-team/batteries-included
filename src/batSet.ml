(* 
 * ExtSet - Extended operations on sets
 * Copyright (C) 1996 Xavier Leroy
 *               2009 David Rajchenbach-Teller, LIFO, Universite d'Orleans
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version,
 * with the special exception on linking described in file LICENSE.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *)


module type OrderedType = BatInterfaces.OrderedType
(** Input signature of the functor {!Set.Make}. *)

module type S =
  sig
    type elt
    (** The type of the set elements. *)

    type t
    (** The type of sets. *)

    val empty: t
    (** The empty set. *)

    val is_empty: t -> bool
    (** Test whether a set is empty or not. *)

    val mem: elt -> t -> bool
    (** [mem x s] tests whether [x] belongs to the set [s]. *)

    val add: elt -> t -> t
    (** [add x s] returns a set containing all elements of [s],
       plus [x]. If [x] was already in [s], [s] is returned unchanged. *)

    val singleton: elt -> t
    (** [singleton x] returns the one-element set containing only [x]. *)

    val remove: elt -> t -> t
    (** [remove x s] returns a set containing all elements of [s],
       except [x]. If [x] was not in [s], [s] is returned unchanged. *)

    val union: t -> t -> t
    (** Set union. *)

    val inter: t -> t -> t
    (** Set intersection. *)

    (** Set difference. *)
    val diff: t -> t -> t

    val compare: t -> t -> int
    (** Total ordering between sets. Can be used as the ordering function
       for doing sets of sets. *)

    val equal: t -> t -> bool
    (** [equal s1 s2] tests whether the sets [s1] and [s2] are
       equal, that is, contain equal elements. *)

    val subset: t -> t -> bool
    (** [subset s1 s2] tests whether the set [s1] is a subset of
       the set [s2]. *)

    val compare_subset: t -> t -> int
    (** Partial ordering between sets as generated by [subset] *)

    val iter: (elt -> unit) -> t -> unit
    (** [iter f s] applies [f] in turn to all elements of [s].
       The elements of [s] are presented to [f] in increasing order
       with respect to the ordering over the type of the elements. *)

    val map: (elt -> elt) -> t -> t
      (** [map f x] creates a new set with elements [f a0],
	  [f a1]... [f an], where [a1], ..., [an] are the
	  values contained in [x]*)

    val filter: (elt -> bool) -> t -> t
    (** [filter p s] returns the set of all elements in [s]
       that satisfy predicate [p]. *)

    val filter_map: (elt -> elt option) -> t -> t
      (** [filter_map f m] combines the features of [filter] and
	  [map].  It calls calls [f a0], [f a1], [f an] where [a0..an]
	  are the elements of [m] and returns the set of pairs [bi]
	  such as [f ai = Some bi] (when [f] returns [None], the
	  corresponding element of [m] is discarded). *)

    val fold: (elt -> 'a -> 'a) -> t -> 'a -> 'a
    (** [fold f s a] computes [(f xN ... (f x2 (f x1 a))...)],
       where [x1 ... xN] are the elements of [s], in increasing order. *)

    val for_all: (elt -> bool) -> t -> bool
    (** [for_all p s] checks if all elements of the set
       satisfy the predicate [p]. *)

    val exists: (elt -> bool) -> t -> bool
    (** [exists p s] checks if at least one element of
       the set satisfies the predicate [p]. *)

    val partition: (elt -> bool) -> t -> t * t
    (** [partition p s] returns a pair of sets [(s1, s2)], where
       [s1] is the set of all the elements of [s] that satisfy the
       predicate [p], and [s2] is the set of all the elements of
       [s] that do not satisfy [p]. *)

    val cardinal: t -> int
    (** Return the number of elements of a set. *)

    val elements: t -> elt list
    (** Return the list of all elements of the given set.
       The returned list is sorted in increasing order with respect
       to the ordering [Ord.compare], where [Ord] is the argument
       given to {!Set.Make}. *)

    val min_elt: t -> elt
    (** Return the smallest element of the given set
       (with respect to the [Ord.compare] ordering), or raise
       [Not_found] if the set is empty. *)

    val max_elt: t -> elt
    (** Same as {!Set.S.min_elt}, but returns the largest element of the
       given set. *)

    val choose: t -> elt
    (** Return one element of the given set, or raise [Not_found] if
       the set is empty. Which element is chosen is unspecified,
       but equal elements will be chosen for equal sets. *)

    val split: elt -> t -> t * bool * t
    (** [split x s] returns a triple [(l, present, r)], where
          [l] is the set of elements of [s] that are
          strictly less than [x];
          [r] is the set of elements of [s] that are
          strictly greater than [x];
          [present] is [false] if [s] contains no element equal to [x],
          or [true] if [s] contains an element equal to [x]. *)

    val enum: t -> elt BatEnum.t
      (** Return an enumeration of all elements of the given set.
	  The returned enumeration is sorted in increasing order with respect
	  to the ordering [Ord.compare], where [Ord] is the argument
	  given to {!Set.Make}. *)

    val backwards: t -> elt BatEnum.t
      (** Return an enumeration of all elements of the given set.
	  The returned enumeration is sorted in decreasing order with respect
	  to the ordering [Ord.compare], where [Ord] is the argument
	  given to {!Set.Make}. *)

    val of_enum: elt BatEnum.t -> t


    (** {6 Boilerplate code}*)

    (** {7 Printing}*)
      
    val print :  ?first:string -> ?last:string -> ?sep:string -> 
      ('a BatInnerIO.output -> elt -> unit) -> 
      'a BatInnerIO.output -> t -> unit

      (** {6 Override modules}*)
      
    (** Operations on {!Set} without exceptions.*)
    module Exceptionless : sig
      val min_elt: t -> elt option
      val max_elt: t -> elt option
      val choose:  t -> elt option
    end
      
      
    (** Operations on {!Set} with labels.
	
	This module overrides a number of functions of {!Set} by
	functions in which some arguments require labels. These labels are
	there to improve readability and safety and to let you change the
	order of arguments to functions. In every case, the behavior of the
	function is identical to that of the corresponding function of {!Set}.
    *)
    module Labels : sig
      val iter : f:(elt -> unit) -> t -> unit
      val fold : f:(elt -> 'a -> 'a) -> t -> init:'a -> 'a
      val for_all : f:(elt -> bool) -> t -> bool
      val exists : f:(elt -> bool) -> t -> bool
      val map: f:(elt -> elt) -> t -> t
      val filter : f:(elt -> bool) -> t -> t
      val filter_map: f:(elt -> elt option) -> t -> t
      val partition : f:(elt -> bool) -> t -> t * t
    end
      
  end
    (** Output signature of the functor {!Set.Make}. *)

  module Make (Ord : OrderedType) = 
  struct
    include Set.Make(Ord)

    (*Breaking the abstraction*)

    type implementation = Empty | Node of implementation * elt * implementation * int
    external impl_of_t : t -> implementation = "%identity"
    external t_of_impl : implementation -> t = "%identity"

(*    let enum t =
      let queue = Queue.create () in
      let rec next () = 
	let item =
	  try Queue.pop queue
	  with Queue.Empty ->
	    raise BatEnum.No_more_elements
	in
	match item with
	  | Empty -> next ()
	  | Node (l, e, r, _) ->
	      Queue.push l queue;
	      Queue.push r queue;
	      e
      in Queue.add (impl_of_t t) queue;
	BatEnum.from next*)

    open Printf
    (* s1 in s2 -> -1, s2 in s1 -> 1, neither a subset -> min_int, eq -> 0 *)
    let rec compare_subset s1 s2 =
      match (s1, impl_of_t s2) with
	  (Empty, Empty) -> 0
	| (Empty, t2) -> -1
	| (t1, Empty) -> 1
	| (Node(l1, v1, r1, _), t2) ->
            match split v1 (t_of_impl t2) with
		(l2, true, r2) -> (* v1 in both s1 and s2 *)
		  ( match compare_subset l1 l2, compare_subset r1 r2 with
		      | -1, -1 | -1, 0 | 0, -1 -> -1
		      | 0, 0 -> 0
		      | 1, 1 | 1, 0 | 0, 1 -> 1
		      | _ -> min_int
		  )
              | (l2, false, r2) -> (* v1 in s1, but not in s2 *)
		  if (compare_subset l1 l2) >= 0 && (compare_subset r1 r2) >= 0
		  then 1 else min_int

    let compare_subset s1 s2 = compare_subset (impl_of_t s1) s2

    type iter = E | C of elt * implementation * iter

    let rec cons_iter s t = match s with
        Empty -> t
      | Node (l, e, r, _) -> cons_iter l (C (e, r, t))

    let rec rev_cons_iter s t = match s with
        Empty -> t
      | Node (l, e, r, _) -> rev_cons_iter r (C (e, l, t))

    let rec enum_next l () = match !l with
        E -> raise BatEnum.No_more_elements
      | C (e, s, t) -> l := cons_iter s t; e

    let rec enum_backwards_next l () = match !l with
        E -> raise BatEnum.No_more_elements
      | C (e, s, t) -> l := rev_cons_iter s t; e

    let rec enum_count l () =
      let rec aux n = function
          E -> n
        | C (e, s, t) -> aux (n + 1 + cardinal (t_of_impl s)) t
      in aux 0 !l

    let enum t =
      let rec make l =
        let l = ref l in
        let clone() = make !l in
          BatEnum.make ~next:(enum_next l) ~count:(enum_count l) ~clone
      in make (cons_iter (impl_of_t t) E)

    let backwards t =
      let rec make l =
        let l = ref l in
        let clone() = make !l in
          BatEnum.make ~next:(enum_backwards_next l) ~count:(enum_count l) ~clone
      in make (rev_cons_iter (impl_of_t t) E)

    let of_enum e = 
      BatEnum.fold (fun acc elem -> add elem acc) empty e

    let map f e = fold (fun x acc -> add (f x) acc) e empty
	
    let filter f e = fold (fun x acc -> if f x then add x acc else acc) e empty

    let filter_map f e = fold (fun x acc -> match f x with Some v -> add v acc | _ -> acc) e empty

    let print ?(first="{\n") ?(last="\n}") ?(sep=",\n") print_elt out t =
      BatEnum.print ~first ~last ~sep print_elt out (enum t)

	
    module Exceptionless =
    struct
      let min_elt t = try Some (min_elt t) with Not_found -> None
      let max_elt t = try Some (max_elt t) with Not_found -> None
      let choose  t = try Some (choose t)  with Not_found -> None
    end

    module Labels =
    struct
      let iter ~f t = iter f t
      let fold ~f t ~init = fold f t init
      let for_all ~f t    = for_all f t
      let exists ~f t     = exists f t
      let map    ~f t     = map f t
      let filter ~f t     = filter f t
      let filter_map ~f t = filter_map f t
      let partition ~f t  = partition f t
    end
  end


  module StringSet  = Make(String)
  module IStringSet = Make(BatString.IString)
  module NumStringSet = Make(BatString.NumString)
  module RopeSet    = Make(BatRope)
  module IRopeSet   = Make(BatRope.IRope)
  module IntSet     = Make(BatInt)

  include BatPSet
